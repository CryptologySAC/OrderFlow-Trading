<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chart.js Trade and Order Book Plot with Range and Tick Selectors</title>
  <style>
    .chartContainer {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 1200px; /* Fixed height for both charts */
    }
    .chartWrapper {
      padding: 10px;
      box-sizing: border-box;
    }
    #tradeChartWrapper {
      width: 75%; /* 3/4 of the container width */
    }
    #orderBookChartWrapper {
      width: 25%; /* 1/4 of the container width */
    }
    .chartAreaWrapper {
      position: relative;
      width: 100%;
      height: 100%; /* Fill the parent wrapper */
    }
    div.rangeSelector, div.tickSelector {
      margin: 10px;
      text-align: center;
    }
    div.rangeSelector button, div.tickSelector button {
      margin: 0 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="rangeSelector">
    <button onclick="setRange(60000)">1m</button>
    <button onclick="setRange(5 * 60000)">5m</button>
    <button onclick="setRange(13 * 60000)">13m</button>
    <button onclick="setRange(89 * 60000)">89m</button>
    <button onclick="setRange(null)">All</button>
  </div>
  <div class="tickSelector">
    <button onclick="setTickGrouping(1)">1 Tick</button>
    <button onclick="setTickGrouping(5)">5 Ticks</button>
    <button onclick="setTickGrouping(10)">10 Ticks</button>
    <button onclick="setTickGrouping(100)">100 Ticks</button>
  </div>
  <div class="chartContainer">
    <div class="chartWrapper" id="tradeChartWrapper">
      <h3>Trades and Signals</h3>
      <div class="chartAreaWrapper">
        <canvas id="tradeChart"></canvas>
      </div>
    </div>
    <div class="chartWrapper" id="orderBookChartWrapper">
      <h3>Order Book Depth</h3>
      <div class="chartAreaWrapper">
        <canvas id="orderBookChart"></canvas>
      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.9/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
    // Trade Chart Setup (Existing)
    const tradeCtx = document.getElementById('tradeChart').getContext('2d');
    const tradeChart = new Chart(tradeCtx, {
      type: 'scatter',
      data: {
        datasets: [{
          label: 'Trades',
          data: [],
          backgroundColor: (context) => {
            const trade = context.raw;
            let color = trade && trade.orderType === 'BUY' ? 'rgba(0, 255, 30, 0.3)' : 'rgba(255,0,90,0.3)';
            if (trade && trade.quantity > 500) {
              color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,25, 0.6)' : 'rgba(255,50,200,0.6)';
            } else if (trade && trade.quantity > 200) {
              color = trade && trade.orderType === 'BUY' ? 'rgba(0,100,25, 0.6)' : 'rgba(255,0,20,0.6)';
            } else if (trade && trade.quantity > 75) {
              color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,30, 0.4)' : 'rgba(255,0,90,0.4)';
            } else if (trade && trade.quantity > 15) {
              color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,30, 0.3)' : 'rgba(255,0,90,0.3)';
            }
            return color;
          },
          pointRadius: (context) => {
            const trade = context.raw;
            let radius;
            if (trade && trade.quantity > 500) {
              radius = 60;
            } else if (trade && trade.quantity > 200) {
              radius = 40;
            } else if (trade && trade.quantity > 75) {
              radius = 20;
            } else if (trade && trade.quantity > 15) {
              radius = 15;
            } else if (trade) {
              radius = trade.quantity;
            } else {
              radius = 1;
            }
            return radius;
          },
          hoverRadius: (context) => {
            const trade = context.raw;
            let radius;
            if (trade && trade.quantity > 500) {
              radius = 60;
            } else if (trade && trade.quantity > 200) {
              radius = 40;
            } else if (trade && trade.quantity > 75) {
              radius = 20;
            } else if (trade && trade.quantity > 15) {
              radius = 15;
            } else if (trade) {
              radius = trade.quantity;
            } else {
              radius = 1;
            }
            return radius;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        layout: {
          padding: {
            right: 20,
            left: 20
          }
        },
        scales: {
          x: {
            type: 'time',
            time: { unit: 'second', round: true, displayFormats: { second: 'HH:mm:ss' } },
            title: { display: false, text: 'Time' },
            bounds: 'data',
            ticks: { source: 'auto' }
          },
          y: {
            type: 'linear',
            ticks: { 
              maxTicksLimit: 50, // Limit to 50 ticks for performance
              precision: 2,
              callback: function(value) {
                return value.toFixed(2); // Ensure 2 decimal places
              }
            },
            title: { display: true, text: 'USDT' },
            position: 'right',
            grace: 0.05,
            offset: true,
          }
        },
        plugins: {
          annotation: {
            annotations: {
              lastPriceLine: {
                type: 'line',
                yMin: undefined,
                yMax: undefined,
                borderColor: 'blue',
                borderWidth: 1,
                drawTime: 'afterDatasetsDraw',
                label: {
                  display: true,
                  content: (ctx) => {
                    const yValue = ctx.chart.options.plugins.annotation.annotations.lastPriceLine.yMin;
                    return yValue ? `${yValue.toFixed(2)}` : '';
                  },
                  position: 'end',
                  xAdjust: -50,
                  yAdjust: 0,
                  backgroundColor: 'rgba(0, 0, 255, 1)',
                  borderColor: 'blue',
                  borderWidth: 2,
                  font: { size: 12 },
                  color: 'white',
                  padding: 6
                }
              }
            }
          },
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (context) => {
                const trade = context.raw;
                return trade ? `Price: ${trade.y}, Qty: ${trade.quantity}, Type: ${trade.orderType}` : '';
              }
            }
          }
        }
      }
    });

    // Order Book Chart Setup (Horizontal Histogram)
    const orderBookCtx = document.getElementById('orderBookChart').getContext('2d');
    const orderBookChart = new Chart(orderBookCtx, {
      type: 'bar',
      data: {
        datasets: [
          {
            label: 'Bids',
            data: [],
            backgroundColor: 'rgba(0, 255, 30, 0.5)',
            borderColor: 'rgba(0, 255, 30, 1)',
            borderWidth: 1,
            barThickness: 10,
            xAxisID: 'x'
          },
          {
            label: 'Asks',
            data: [],
            backgroundColor: 'rgba(255, 0, 90, 0.5)',
            borderColor: 'rgba(255, 0, 90, 1)',
            borderWidth: 1,
            barThickness: 10,
            xAxisID: 'x'
          },
          {
            label: 'Current Price',
            data: [],
            type: 'line',
            borderColor: 'blue',
            borderWidth: 1,
            pointRadius: 0,
            yAxisID: 'y',
            xAxisID: 'x-hidden',
            fill: false
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        indexAxis: 'y', // Horizontal bars
        layout: {
          padding: {
            right: 20,
            left: 20
          }
        },
        scales: {
          x: {
            type: 'linear',
            position: 'top',
            title: { display: true, text: 'Quantity' },
            ticks: {
              callback: (value) => Math.abs(value).toFixed(0) // Show absolute values
            },
            grid: { drawOnChartArea: true },
            min: -500, // Adjust based on expected max quantity
            max: 500
          },
          'x-hidden': {
            type: 'linear',
            display: false,
            min: -0.5,
            max: 0.5
          },
          y: {
            type: 'linear',
            ticks: { 
              maxTicksLimit: 50, // Limit to 50 ticks for performance
              precision: 2,
              callback: (value) => value.toFixed(2)
            },
            title: { display: true, text: 'Price (USDT)' },
            grace: 0.05,
            offset: true,
          }
        },
        plugins: {
          legend: { display: true },
          tooltip: {
            callbacks: {
              label: (context) => {
                const data = context.raw;
                if (context.dataset.label === 'Current Price') {
                  return `Current Price: ${data.y.toFixed(2)}`;
                }
                return `${context.dataset.label}: Price: ${data.y.toFixed(2)}, Qty: ${Math.abs(data.x).toFixed(2)}`;
              }
            }
          }
        }
      }
    });

    // Data and state
    const trades = [];
    const orderBookData = { bids: [], asks: [], lastPrice: null };
    const maxTrades = 20000;
    const maxOrderBookLevels = 10; // Display up to 10 price levels per side
    let annotationId = 0;
    let activeRange = null;
    let tickGrouping = 1; // Default to 1 tick (0.01 USDT)
    const tickSize = 0.01; // 1 tick = 0.01 USDT
    const paddingTime = 20000; // 20 seconds margin for latest marker

    // Validate trade data
    function isValidTrade(trade) {
      if (!trade) {
        console.warn('Invalid trade: null or undefined');
        return false;
      }
      if (typeof trade.time !== 'number' || isNaN(trade.time) || !isFinite(trade.time)) {
        console.warn('Invalid trade time:', trade.time);
        return false;
      }
      if (typeof trade.price !== 'number' || isNaN(trade.price) || !isFinite(trade.price)) {
        console.warn('Invalid trade price:', trade.price);
        return false;
      }
      if (typeof trade.quantity !== 'number' || isNaN(trade.quantity) || !isFinite(trade.quantity)) {
        console.warn('Invalid trade quantity:', trade.quantity);
        return false;
      }
      if (!['BUY', 'SELL'].includes(trade.orderType)) {
        console.warn('Invalid trade orderType:', trade.orderType);
        return false;
      }
      return true;
    }

    // Validate order book data
    function isValidOrderBookUpdate(data) {
      if (!data || !data.e || data.e !== 'depthUpdate') {
        console.warn('Invalid order book update:', data);
        return false;
      }
      if (!Array.isArray(data.b) || !Array.isArray(data.a)) {
        console.warn('Invalid bids or asks in order book update:', data);
        return false;
      }
      return true;
    }

    // Set tick grouping for the order book
    function setTickGrouping(ticks) {
      tickGrouping = ticks;
      // Reprocess the order book with the new tick grouping
      updateOrderBook([], []); // Trigger an update with the current data
    }

    // Update order book state with tick grouping
    function updateOrderBook(bids, asks) {
      const updateLevels = (existingLevels, updates) => {
        const levelMap = {};
        existingLevels.forEach(level => {
          levelMap[level.price] = level.quantity;
        });
        updates.forEach(([price, quantity]) => {
          levelMap[price] = quantity;
        });
        const updatedLevels = [];
        for (const price in levelMap) {
          const quantity = parseFloat(levelMap[price]);
          if (quantity > 0) {
            updatedLevels.push({ price: parseFloat(price), quantity });
          }
        }
        return updatedLevels.sort((a, b) => a.price - b.price); // Sort ascending by price
      };

      // Update bids and asks with raw data
      const newBids = updateLevels(orderBookData.bids, bids);
      const newAsks = updateLevels(orderBookData.asks, asks);

      // Group levels by tick size
      const groupLevels = (levels) => {
        const bucketSize = tickSize * tickGrouping;
        const groupedMap = {};
        
        levels.forEach(level => {
          // Round price to the nearest bucket
          const bucketPrice = Math.round(level.price / bucketSize) * bucketSize;
          const roundedPrice = parseFloat(bucketPrice.toFixed(2));
          
          if (!groupedMap[roundedPrice]) {
            groupedMap[roundedPrice] = 0;
          }
          groupedMap[roundedPrice] += level.quantity;
        });

        const groupedLevels = [];
        for (const price in groupedMap) {
          groupedLevels.push({ price: parseFloat(price), quantity: groupedMap[price] });
        }
        return groupedLevels.sort((a, b) => a.price - b.price); // Sort ascending by price
      };

      // Group bids and asks
      const groupedBids = groupLevels(newBids);
      const groupedAsks = groupLevels(newAsks);

      // Ensure asks are above bids by filtering overlapping levels
      const highestBidPrice = groupedBids.length > 0 ? groupedBids[groupedBids.length - 1].price : -Infinity;
      const lowestAskPrice = groupedAsks.length > 0 ? groupedAsks[0].price : Infinity;

      // Filter bids to ensure they are below the lowest ask
      orderBookData.bids = groupedBids.filter(bid => bid.price < lowestAskPrice).slice(-maxOrderBookLevels).reverse(); // Top bids (highest prices)

      // Filter asks to ensure they are above the highest bid
      orderBookData.asks = groupedAsks.filter(ask => ask.price > highestBidPrice).slice(0, maxOrderBookLevels); // Top asks (lowest prices)

      // Prepare data for the horizontal histogram
      const bidData = orderBookData.bids.map(bid => ({
        x: -bid.quantity, // Negative for bids (extend left)
        y: bid.price
      }));
      const askData = orderBookData.asks.map(ask => ({
        x: ask.quantity, // Positive for asks (extend right)
        y: ask.price
      }));

      // Add current price line using the last trade price
      const priceLineData = orderBookData.lastPrice ? [{
        x: -0.5,
        y: orderBookData.lastPrice
      }, {
        x: 0.5,
        y: orderBookData.lastPrice
      }] : [];

      // Update the order book chart
      orderBookChart.data.datasets[0].data = bidData;
      orderBookChart.data.datasets[1].data = askData;
      orderBookChart.data.datasets[2].data = priceLineData;

      // Adjust X-axis limits based on max quantities
      const maxBidQty = Math.max(...bidData.map(d => Math.abs(d.x)), 0);
      const maxAskQty = Math.max(...askData.map(d => d.x), 0);
      const maxQty = Math.max(maxBidQty, maxAskQty, 500); // Ensure a minimum range
      orderBookChart.options.scales.x.min = -maxQty;
      orderBookChart.options.scales.x.max = maxQty;

      // Adjust Y-axis limits based on price range
      const allPrices = [...bidData.map(d => d.y), ...askData.map(d => d.y)];
      if (orderBookData.lastPrice) {
        allPrices.push(orderBookData.lastPrice); // Include current price in range
      }
      if (allPrices.length > 0) {
        const minPrice = Math.min(...allPrices);
        const maxPrice = Math.max(...allPrices);
        orderBookChart.options.scales.y.min = minPrice - (maxPrice - minPrice) * 0.05;
        orderBookChart.options.scales.y.max = maxPrice + (maxPrice - minPrice) * 0.05;
      }

      orderBookChart.update('none');
    }

    // Set X-axis range for the trade chart (order book chart doesn’t need time range)
    function setRange(duration) {
      activeRange = duration;
      const now = Date.now();
      if (duration) {
        tradeChart.options.scales.x.min = now - duration;
        tradeChart.options.scales.x.max = now + paddingTime;
      } else {
        tradeChart.options.scales.x.min = undefined;
        tradeChart.options.scales.x.max = undefined;
      }
      tradeChart.update();
      // Order book chart doesn’t need time range adjustment
    }

    // WebSocket for real-time updates
    const ws = new WebSocket('ws://localhost:3001');
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      if (message.type === 'backlog') {
        console.log('%s backlog trades received.', message.data.length);
        trades.length = 0;
        message.data.forEach(t => {
          if (isValidTrade(t)) {
            trades.push({ x: t.time, y: t.price, quantity: t.quantity, orderType: t.orderType });
          }
        });
        while (trades.length > maxTrades) trades.shift();
        console.log('%s backlog trades processed.', trades.length);
        tradeChart.data.datasets[0].data = trades;
        if (trades.length > 0) {
          const latestPrice = trades[trades.length - 1].y;
          orderBookData.lastPrice = latestPrice; // Update last price from trade data
          tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMin = latestPrice;
          tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMax = latestPrice;
          if (activeRange !== null) {
            const latestTime = trades[trades.length - 1].x;
            tradeChart.options.scales.x.min = latestTime - activeRange;
            tradeChart.options.scales.x.max = latestTime + paddingTime;
          }
        }
        tradeChart.update();
      } else if (message.type === 'trade') {
        const trade = message.data;
        if (isValidTrade(trade)) {
          trades.push({ x: trade.time, y: trade.price, quantity: trade.quantity, orderType: trade.orderType });
          while (trades.length > maxTrades) trades.shift();
          tradeChart.data.datasets[0].data = trades;
          tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMin = trade.price;
          tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMax = trade.price;
          orderBookData.lastPrice = trade.price; // Update last price from trade data
          if (activeRange !== null) {
            tradeChart.options.scales.x.max = trade.time + paddingTime;
            tradeChart.options.scales.x.min = trade.time - activeRange;
          }
          tradeChart.update('none');
          // Trigger an order book chart update to reflect the new current price
          updateOrderBook([], []); // Pass empty updates to refresh the price line
        }
      } else if (message.type === 'signal') {
        const label = message.data;
        tradeChart.options.plugins.annotation.annotations[label.tradeIndex] = {
          type: 'label',
          xValue: label.time,
          yValue: label.price,
          content: label.type + " | " + label.status,
          backgroundColor: 'rgba(90, 50, 255, 1)',
          color: 'white',
          font: { size: 14 },
          padding: 8,
          id: label.tradeIndex
        };
        tradeChart.update('none');
        console.log('Signal label added:', label);
      } else if (message.type === 'orderbook') {
        const data = message.data;
        if (isValidOrderBookUpdate(data)) {
          updateOrderBook(data.b, data.a);
        }
      }
    };

    ws.onopen = () => console.log('Connected to WebSocket');
    ws.onerror = (error) => console.error('WebSocket error:', error);
    ws.onclose = () => console.log('WebSocket closed');
  </script>
</body>
</html>