<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LTCUSDT Market Flow Chart</title>
  <style>
    .chartContainer {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 1200px; /* Fixed height for both charts */
    }
    .chartWrapper {
      padding: 10px;
      box-sizing: border-box;
    }
    #tradeChartWrapper {
      width: 75%; /* 3/4 of the container width */
    }
    #orderBookChartWrapper {
      width: 20%; /* 1/4 of the container width */
    }
    .chartAreaWrapper {
      position: relative;
      width: 100%;
      height: 100%; /* Fill the parent wrapper */
    }
    div.rangeSelector, div.tickSelector {
      margin: 10px;
      text-align: center;
    }
    div.rangeSelector button, div.tickSelector button {
      margin: 0 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
    div.selectors div {
        float: right;
        padding: 10px;
        display: ruby;
    }
  </style>
</head>
<body>
    <h1>Binance Spot LTCUSDT</h1>
    <div class="selectors">
        <div class="tickSelector">
            <h3>Grouping</h3>
            <button onclick="setTickGrouping(5)">0.05</button>
            <button onclick="setTickGrouping(10)">0.1</button>
            <button onclick="setTickGrouping(100)">1</button>
        </div>
        <div class="rangeSelector">
            <h3>Time Range</h3>
            <button onclick="setRange(60000)">1m</button>
            <button onclick="setRange(5 * 60000)">5m</button>
            <button onclick="setRange(13 * 60000)">13m</button>
            <button onclick="setRange(89 * 60000)">89m</button>
            <button onclick="setRange(null)">All</button>
        </div>        
    </div>
    <div class="chartContainer">
        <div class="chartWrapper" id="tradeChartWrapper">
            <h2>Trades and Signals</h2>
            <div class="chartAreaWrapper">
                <canvas id="tradeChart"></canvas>
            </div>
        </div>
        <div class="chartWrapper" id="orderBookChartWrapper">
            <h2>Order Book</h2>
            <div class="chartAreaWrapper">
                <canvas id="orderBookChart"></canvas>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.9/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.min.js"></script>

    <script>
        // Trade Chart Setup (Existing)
        const tradeCtx = document.getElementById('tradeChart').getContext('2d');
        const tradeChart = new Chart(tradeCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Trades',
                    data: [],
                    backgroundColor: (context) => {
                        const trade = context.raw;
                        let color = trade && trade.orderType === 'BUY' ? 'rgba(0, 255, 30, 0.3)' : 'rgba(255,0,90,0.3)';
                        if (trade && trade.quantity > 500) {
                            color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,25, 0.6)' : 'rgba(255,50,200,0.6)';
                        } else if (trade && trade.quantity > 200) {
                            color = trade && trade.orderType === 'BUY' ? 'rgba(0,100,25, 0.6)' : 'rgba(255,0,20,0.6)';
                        } else if (trade && trade.quantity > 75) {
                            color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,30, 0.4)' : 'rgba(255,0,90,0.4)';
                        } else if (trade && trade.quantity > 15) {
                            color = trade && trade.orderType === 'BUY' ? 'rgba(0,255,30, 0.3)' : 'rgba(255,0,90,0.3)';
                        }
                        return color;
                    },
                    pointRadius: (context) => {
                        const trade = context.raw;
                        let radius;
                        if (trade && trade.quantity > 500) {
                            radius = 60;
                        } else if (trade && trade.quantity > 200) {
                            radius = 40;
                        } else if (trade && trade.quantity > 75) {
                            radius = 20;
                        } else if (trade && trade.quantity > 15) {
                            radius = 15;
                        } else if (trade) {
                            radius = trade.quantity;
                        } else {
                            radius = 1;
                        }
                        return radius;
                    },
                    hoverRadius: (context) => {
                        const trade = context.raw;
                        let radius;
                        if (trade && trade.quantity > 500) {
                            radius = 60;
                        } else if (trade && trade.quantity > 200) {
                            radius = 40;
                        } else if (trade && trade.quantity > 75) {
                            radius = 20;
                        } else if (trade && trade.quantity > 15) {
                            radius = 15;
                        } else if (trade) {
                            radius = trade.quantity;
                        } else {
                            radius = 1;
                        }
                        return radius;
                    },
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                layout: {
                    padding: {
                        right: 20,
                        left: 20
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'minute', round: true, displayFormats: { minute: 'HH:mm' } },
                        title: { display: false, text: 'Time' },
                        ticks: { source: 'auto' }
                    },
                    y: {
                        type: 'linear',
                        ticks: { 
                            maxTicksLimit: 50, // Limit to 50 ticks for performance
                            precision: 2,
                            callback: function(value) {
                                return value.toFixed(2); // Ensure 2 decimal places
                            }
                        },
                        title: { display: false, text: 'USDT' },
                        position: 'right',
                        grace: 0.05,
                        offset: false,
                        grid: {
                            drawOnChartArea: true,
                            offset: false,
                        }
                    }
                },
                plugins: {
                    annotation: {
                        annotations: {
                            lastPriceLine: {
                                type: 'line',
                                yMin: undefined,
                                yMax: undefined,
                                borderColor: 'blue',
                                borderWidth: 1,
                                drawTime: 'afterDatasetsDraw',
                                label: {
                                    display: true,
                                    content: (ctx) => {
                                        const yValue = ctx.chart.options.plugins.annotation.annotations.lastPriceLine.yMin;
                                        return yValue ? `${yValue.toFixed(2)}` : '';
                                    },
                                    position: 'end',
                                    xAdjust: -50,
                                    yAdjust: 0,
                                    backgroundColor: 'rgba(0, 0, 255, 1)',
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    font: { size: 12 },
                                    color: 'white',
                                    padding: 6
                                }
                            }
                        }
                    },
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const trade = context.raw;
                                return trade ? `Price: ${trade.y}, Qty: ${trade.quantity}, Type: ${trade.orderType}` : '';
                            }
                        }
                    }
                }
            }
        });

        // Order Book Chart Setup (Horizontal Histogram)
        const orderBookCtx = document.getElementById('orderBookChart').getContext('2d');
        const orderBookChart = new Chart(orderBookCtx, {
            type: 'bar',
            data: {
                datasets: [
                {
                    label: 'Bids',
                    data: [],
                    backgroundColor: 'rgba(0, 255, 30, 0.5)',
                    borderColor: 'rgba(0, 255, 30, 1)',
                    borderWidth: 1,
                    xAxisID: 'x'
                },
                {
                    label: 'Asks',
                    data: [],
                    backgroundColor: 'rgba(255, 0, 90, 0.5)',
                    borderColor: 'rgba(255, 0, 90, 1)',
                    borderWidth: 1,
                    xAxisID: 'x'
                },
                {
                    label: 'Current Price',
                    data: [],
                    type: 'line',
                    borderColor: 'blue',
                    borderWidth: 1,
                    pointRadius: 0,
                    yAxisID: 'y',
                    xAxisID: 'x-hidden',
                    fill: false
                }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                indexAxis: 'y', // Horizontal bars
                layout: {
                    padding: {
                        right: 20,
                        left: 20
                    },
                },
                scales: { 
                    x: {
                        type: 'linear',
                        grid: {
                            display: false
                        },                        
                        title: { display: false, text: 'Amount (LTC)' },
                        bounds: 'data',
                        ticks: { 
                            maxTicksLimit: 50, // Limit to 50 ticks for performance

                            precision: 0,
                            callback: function(value) {
                                return (value/1000).toFixed(0)+ 'K'; // Format as thousands
                            },
                        }, 
                    },
                    'x-hidden': {
                        type: 'linear',
                        display: false,
                        min: -0.5,
                        max: 0.5
                    },
                    y: {
                        type: 'linear',
                        ticks: { 
                            maxTicksLimit: 50, // Limit to 50 ticks for performance
                            precision: 2,
                            callback: function(value) {
                                return value.toFixed(2); // Ensure 2 decimal places
                            }
                        },
                        title: { display: false, text: 'USDT' },
                        position: 'left',
                        grace: 0.05,
                        offset: false,
                        grid: { 
                            drawOnChartArea: true,
                            offset: false,
                        },
                    },
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const data = context.raw;
                                if (context.dataset.label === 'Current Price') {
                                    return `Current Price: ${data.y.toFixed(2)}`;
                                }
                                return `${context.dataset.label}: Price: ${data.y.toFixed(2)}, Qty: ${Math.abs(data.x).toFixed(2)}`;
                            }
                        }
                    },
                },
            },
        });

        const ws = new WebSocket('ws://localhost:3001');
        let lastPrice = 0;
        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.type === 'backlog') {
                console.log('%s backlog trades received.', message.data.length);
                trades.length = 0;
                message.data.forEach(t => {
                    if (isValidTrade(t)) {
                        trades.push({ x: t.time, y: t.price, quantity: t.quantity, orderType: t.orderType });
                    }
                });
                while (trades.length > maxTrades) trades.shift();
                console.log('%s backlog trades processed.', trades.length);
                tradeChart.data.datasets[0].data = trades;
                if (trades.length > 0) {
                    tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMin = trades[trades.length - 1].y;
                    tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMax = trades[trades.length - 1].y;
                    if (activeRange !== null) {
                        const latestTime = trades[trades.length - 1].x;
                    }
                }
                tradeChart.update();
            } else if (message.type === 'trade') {
                const trade = message.data;
                if (isValidTrade(trade)) {
                    trades.push({ x: trade.time, y: trade.price, quantity: trade.quantity, orderType: trade.orderType });
                    while (trades.length > maxTrades) trades.shift();
                    tradeChart.data.datasets[0].data = trades;
                    tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMin = trade.price;
                    tradeChart.options.plugins.annotation.annotations.lastPriceLine.yMax = trade.price;
                    orderBookData.lastPrice = trade.price; // Update last price from trade data
                    lastPrice = trade.price
                    if (activeRange !== null) {
                        tradeChart.options.scales.x.max = trade.time + paddingTime;
                        tradeChart.options.scales.x.min = trade.time - activeRange;
                    }
                    tradeChart.update('none');
                    // Trigger an order book chart update to reflect the new current price
                    updateOrderBook([], []); // Pass empty updates to refresh the price line
                }
            } else if (message.type === 'signal') {
                const label = message.data;
                tradeChart.options.plugins.annotation.annotations[label.tradeIndex] = {
                    type: 'label',
                    xValue: label.time,
                    yValue: label.price,
                    content: label.type + " | " + label.status,
                    backgroundColor: 'rgba(90, 50, 255, 1)',
                    color: 'white',
                    font: { size: 14 },
                    padding: 8,
                    id: label.tradeIndex
                };
                tradeChart.update('none');
                console.log('Signal label added:', label);
            } else if (message.type === 'orderbook') {
                const data = message.data;
                if (isValidOrderBookUpdate(data)) {
                   updateOrderBook(data.bids, data.asks);
                }
            }

            syncYAxes();
        };

        ws.onopen = () => console.log('Connected to WebSocket');
        ws.onerror = (error) => console.error('WebSocket error:', error);
        ws.onclose = () => console.log('WebSocket closed');

        const trades = [];
        const orderBookData = { bids: [], asks: [], lastPrice: null };
        const maxTrades = 20000;
        let annotationId = 0;
        let activeRange = null;
        let tickGrouping = 10; // Default to 10 ticks (0.10 USDT)
        const tickSize = 0.01; // 1 tick = 0.01 USDT
        const maxOrderBookLevels = 500; // Display up to 50 price levels per side

        // Validate trade data
        function isValidTrade(trade) {
            if (!trade) {
                console.warn('Invalid trade: null or undefined');
                return false;
            }
            if (typeof trade.time !== 'number' || isNaN(trade.time) || !isFinite(trade.time)) {
                console.warn('Invalid trade time:', trade.time);
                return false;
            }
            if (typeof trade.price !== 'number' || isNaN(trade.price) || !isFinite(trade.price)) {
                console.warn('Invalid trade price:', trade.price);
                return false;
            }
            if (typeof trade.quantity !== 'number' || isNaN(trade.quantity) || !isFinite(trade.quantity)) {
                console.warn('Invalid trade quantity:', trade.quantity);
                return false;
            }
            if (!['BUY', 'SELL'].includes(trade.orderType)) {
                console.warn('Invalid trade orderType:', trade.orderType);
                return false;
            }
            return true;
        }

        // Validate order book data
        function isValidOrderBookUpdate(data) {
            if (!Array.isArray(data.bids) || !Array.isArray(data.asks)) {
                console.warn('Invalid bids or asks in order book update:', data);
                return false;
            }
            return true;
        }

        // Update order book state with tick grouping
        function updateOrderBook(bids, asks) {
            const updateLevels = (existingLevels, updates) => {
                const levelMap = {};
                existingLevels.forEach(level => {
                    levelMap[level.price] = level.quantity;
                });
                updates.forEach(([price, quantity]) => {
                    levelMap[price] = quantity;
                });
                const updatedLevels = [];
                for (const price in levelMap) {
                    const quantity = parseFloat(levelMap[price]);
                    if (quantity > 0) {
                        updatedLevels.push({ price: parseFloat(price), quantity });
                    }
                }
                return updatedLevels.sort((a, b) => a.price - b.price); // Sort ascending by price
            };

            // Update bids and asks with raw data
            const newBids = updateLevels(orderBookData.bids, bids);
            const newAsks = updateLevels(orderBookData.asks, asks);

            // Group levels by tick size
            const groupLevels = (levels) => {
                const bucketSize = tickSize * tickGrouping;
                const groupedMap = {};
        
                levels.forEach(level => {
                    // Round price to the nearest bucket
                    const bucketPrice = Math.round(level.price / bucketSize) * bucketSize;
                    const roundedPrice = parseFloat(bucketPrice.toFixed(2));
          
                    if (!groupedMap[roundedPrice]) {
                        groupedMap[roundedPrice] = 0;
                    }
                    groupedMap[roundedPrice] += level.quantity;
                });

                const groupedLevels = [];
                for (const price in groupedMap) {
                    groupedLevels.push({ price: parseFloat(price), quantity: groupedMap[price] });
                }
                return groupedLevels.sort((a, b) => a.price - b.price); // Sort ascending by price
            };

            // Group bids and asks
            const groupedBids = groupLevels(newBids);
            const groupedAsks = groupLevels(newAsks);

            // Ensure asks are above bids by filtering overlapping levels
            const highestBidPrice = groupedBids.length > 0 ? groupedBids[groupedBids.length - 1].price : -Infinity;
            const lowestAskPrice = groupedAsks.length > 0 ? groupedAsks[0].price : Infinity;

            // Filter bids to ensure they are below the lowest ask
            orderBookData.bids = newBids.filter(bid => bid.price < lastPrice).slice(-maxOrderBookLevels).reverse(); // Top bids (highest prices)

            // Filter asks to ensure they are above the highest bid
            orderBookData.asks = newAsks.filter(ask => ask.price > lastPrice).slice(0, maxOrderBookLevels); // Top asks (lowest prices)

            // Prepare data for the horizontal histogram
            const bidData = orderBookData.bids.map(bid => ({
                x: bid.quantity, // Negative for bids (extend left)
                y: bid.price
            }));
            const askData = orderBookData.asks.map(ask => ({
                x: ask.quantity, // Positive for asks (extend right)
                y: ask.price
            }));

            // Add current price line using the last trade price
            const priceLineData = orderBookData.lastPrice ? [{
                    x: -0.5,
                    y: orderBookData.lastPrice
                }, {
                    x: 0.5,
                    y: orderBookData.lastPrice
            }] : [];

            // Update the order book chart
            orderBookChart.data.datasets[0].data = bidData;
            orderBookChart.data.datasets[1].data = askData;
            orderBookChart.data.datasets[2].data = priceLineData;

            // Adjust X-axis limits based on max quantities
            //const maxBidQty = Math.max(...bidData.map(d => Math.abs(d.x)), 0);
            //const maxAskQty = Math.max(...askData.map(d => d.x), 0);
            //const maxQty = Math.max(maxBidQty, maxAskQty, 500); // Ensure a minimum range
            //orderBookChart.options.scales.x.min = -maxQty;
            //orderBookChart.options.scales.x.max = maxQty;
            orderBookChart.update('none');
        }

        // Synchronize Y-axis limits across all charts
        function syncYAxes() {
            const tradePrices = trades.map(trade => trade.y);

            const minPrice = Math.min(...tradePrices);
            const maxPrice = Math.max(...tradePrices);
            const range = maxPrice - minPrice;
            const padding = range * 0.25; // 25% padding
            const yMin = minPrice - padding;
            const yMax = maxPrice + padding;

            // Update Y-axis limits for all charts
            tradeChart.options.scales.y.min = yMin;
            tradeChart.options.scales.y.max = yMax;
            orderBookChart.options.scales.y.min = tradeChart.options.scales.y.min;
            orderBookChart.options.scales.y.max = tradeChart.options.scales.y.max;

            tradeChart.update('none');
            orderBookChart.update('none');
        }
    </script>
</body>
</html>