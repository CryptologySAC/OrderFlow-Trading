 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/trading/signalManager.ts b/src/trading/signalManager.ts
index 4c6816af4eb35a0ec6280894c614932102f6e2b5..515081503c9e59ad10ee6360dd5f57a0176c5a09 100644
--- a/src/trading/signalManager.ts
+++ b/src/trading/signalManager.ts
@@ -23,64 +23,136 @@ import {
 import type {
     SignalTracker,
     PerformanceMetrics,
 } from "../analysis/signalTracker.js";
 import type { MarketContextCollector } from "../analysis/marketContextCollector.js";
 
 export interface SignalManagerConfig {
     confidenceThreshold?: number;
     signalTimeout?: number;
     enableMarketHealthCheck?: boolean;
     enableAlerts?: boolean;
 }
 
 interface SignalCorrelation {
     signalId: string;
     correlatedSignals: ProcessedSignal[];
     timestamp: number;
     strength: number;
 }
 
 /**
  * Simplified SignalManager focused on signal coordination and market health gatekeeper.
  * Uses AnomalyDetector only for market health checks, not signal enhancement.
  */
 export class SignalManager extends EventEmitter {
+    /**
+     * Priority queue to throttle signals by confidence per symbol.
+     * Keeps the top N signals within a rolling time window.
+     */
+    private static PriorityThrottleQueue = class {
+        private readonly queue = new Map<string, ProcessedSignal[]>();
+
+        constructor(
+            private readonly capacity: number,
+            private readonly windowMs: number
+        ) {}
+
+        public tryAdd(signal: ProcessedSignal): boolean {
+            const data = signal.data as unknown as {
+                symbol?: string;
+                severity?: string;
+            };
+            const symbol = data.symbol ?? "UNKNOWN";
+            const severity = data.severity;
+            const now = Date.now();
+
+            const list = this.queue.get(symbol) ?? [];
+            const filtered = list.filter(
+                (s) => now - s.timestamp.getTime() <= this.windowMs
+            );
+
+            if (list.length !== filtered.length) {
+                this.queue.set(symbol, filtered);
+            }
+
+            if (severity === "critical") {
+                this.insert(filtered, signal);
+                this.trim(filtered);
+                this.queue.set(symbol, filtered);
+                return true;
+            }
+
+            if (filtered.length < this.capacity) {
+                this.insert(filtered, signal);
+                this.queue.set(symbol, filtered);
+                return true;
+            }
+
+            const lowest = filtered[filtered.length - 1];
+            if (signal.confidence <= lowest.confidence) {
+                return false;
+            }
+
+            this.insert(filtered, signal);
+            this.trim(filtered);
+            this.queue.set(symbol, filtered);
+            return true;
+        }
+
+        private insert(list: ProcessedSignal[], signal: ProcessedSignal): void {
+            list.push(signal);
+            list.sort((a, b) => b.confidence - a.confidence);
+        }
+
+        private trim(list: ProcessedSignal[]): void {
+            if (list.length > this.capacity) {
+                list.length = this.capacity;
+            }
+        }
+    };
+
     private readonly config: Required<SignalManagerConfig>;
     private readonly recentSignals = new Map<string, ProcessedSignal>();
     private readonly correlations = new Map<string, SignalCorrelation>();
     private readonly signalHistory: ProcessedSignal[] = [];
     private lastRejectReason?: string;
 
     // Keep track of signals for correlation analysis
     private readonly maxHistorySize = 100;
     private readonly correlationWindowMs = 60000; // 1 minute
 
     // Signal throttling and deduplication
     private readonly recentTradingSignals = new Map<string, number>(); // signalKey -> timestamp
     private readonly signalThrottleMs = 30000; // 30 seconds minimum between similar signals
-    private readonly priceTolerancePercent = 0.02; // 0.02% price tolerance for duplicates - very tight for precise deduplication
+    private readonly priceTolerancePercent = 0.05; // 0.05% price tolerance for duplicates - slightly wider for deduplication
+
+    // Priority throttling for top signals per symbol
+    private readonly priorityQueue = new SignalManager.PriorityThrottleQueue(
+        3,
+        5 * 60 * 1000
+    );
 
     constructor(
         private readonly anomalyDetector: AnomalyDetector,
         private readonly alertManager: AlertManager,
         private readonly logger: Logger,
         private readonly metricsCollector: MetricsCollector,
         private readonly storage: IPipelineStorage,
         private readonly signalTracker?: SignalTracker,
         private readonly marketContextCollector?: MarketContextCollector,
         config: Partial<SignalManagerConfig> = {}
     ) {
         super();
 
         this.config = {
             confidenceThreshold: config.confidenceThreshold ?? 0.75,
             signalTimeout: config.signalTimeout ?? 300000,
             enableMarketHealthCheck: config.enableMarketHealthCheck ?? true,
             enableAlerts: config.enableAlerts ?? true,
         };
 
         this.logger.info(
             "SignalManager initialized as market health gatekeeper",
             {
                 component: "SignalManager",
                 config: this.config,
diff --git a/src/trading/signalManager.ts b/src/trading/signalManager.ts
index 4c6816af4eb35a0ec6280894c614932102f6e2b5..515081503c9e59ad10ee6360dd5f57a0176c5a09 100644
--- a/src/trading/signalManager.ts
+++ b/src/trading/signalManager.ts
@@ -359,50 +431,70 @@ export class SignalManager extends EventEmitter {
         let confirmedSignal: ConfirmedSignal | null = null;
         try {
             this.logger.info("Handling processed signal", {
                 component: "SignalManager",
                 operation: "handleProcessedSignal",
                 signalId: signal.id,
                 signalType: signal.type,
                 detectorId: signal.detectorId,
                 confidence: signal.confidence,
             });
 
             this.metricsCollector.incrementCounter(
                 "signal_manager_signals_received_total",
                 1,
                 {
                     signal_type: signal.type,
                     detector_id: signal.detectorId,
                 }
             );
             // Track received signals by type for stats page
             this.metricsCollector.incrementCounter(
                 `signal_manager_signals_received_total_${signal.type}`,
                 1
             );
 
+            // Apply priority throttling per symbol
+            if (!this.priorityQueue.tryAdd(signal)) {
+                this.logger.info("Signal discarded by priority queue", {
+                    signalId: signal.id,
+                    signalType: signal.type,
+                    confidence: signal.confidence,
+                });
+                this.recordDetailedSignalMetrics(
+                    signal,
+                    "rejected",
+                    "throttled_priority"
+                );
+                this.lastRejectReason = "throttled_priority";
+                this.emit("signalRejected", {
+                    signal,
+                    reason: this.lastRejectReason,
+                });
+                return null;
+            }
+
             // Store signal for correlation analysis
             this.storeSignal(signal);
 
             // Process signal through simplified pipeline
             confirmedSignal = this.processSignal(signal);
 
             if (!confirmedSignal) {
                 this.emit("signalRejected", {
                     signal,
                     reason: this.lastRejectReason ?? "processing_failed",
                 });
                 return null;
             }
 
             // Generate final trading signal
             const tradingSignal = this.createTradingSignal(confirmedSignal);
 
             // Check for duplicate/throttled signals
             if (this.isSignalThrottled(tradingSignal)) {
                 this.logger.info("Signal throttled to prevent duplicates", {
                     signalId: tradingSignal.id,
                     type: tradingSignal.type,
                     price: tradingSignal.price,
                     side: tradingSignal.side,
                 });
 
EOF
)