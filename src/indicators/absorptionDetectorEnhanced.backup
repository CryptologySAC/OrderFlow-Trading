// src/indicators/absorptionDetectorEnhanced.ts
//
// âœ… ABSORPTION DETECTOR: CLAUDE.md Compliant Enhanced Absorption Detection
//
// This file implements AbsorptionDetectorEnhanced as a detector that extends
// BaseDetector.
//
// ARCHITECTURE APPROACH:
// - CLAUDE.md compliant: All magic numbers configurable, FinancialMath usage
// - Zone-agnostic: Uses Universal Zones from preprocessor instead of legacy zone management
// - Clean signals: Independent signal emission based on actual absorption patterns
//
// KEY FEATURES:
// - Multi-timeframe absorption pattern analysis (5T, 10T, 20T)
// - Institutional volume absorption detection using Universal Zones
// - Enhanced absorption scoring with zone confluence
//

import { Detector } from "./base/detectorEnrichedTrade.js";
import { FinancialMath } from "../utils/financialMath.js";
import { SignalValidationLogger } from "../utils/signalValidationLogger.js";
import {
    AbsorptionZoneTracker,
    type AbsorptionTrackerConfig,
} from "./helpers/absorptionZoneTracker.js";
import type { ILogger } from "../infrastructure/loggerInterface.js";
import type { IMetricsCollector } from "../infrastructure/metricsCollectorInterface.js";
import type { IOrderflowPreprocessor } from "../market/orderFlowPreprocessor.js";
import type {
    EnrichedTradeEvent,
    StandardZoneData,
    ZoneSnapshot,
} from "../types/marketEvents.js";
import type {
    SignalCandidate,
    EnhancedAbsorptionSignalData,
    SignalType,
    AbsorptionThresholdChecks,
} from "../types/signalTypes.js";
import { z } from "zod";
import { AbsorptionDetectorSchema, Config } from "../core/config.js";
import type { ISignalLogger } from "../infrastructure/signalLoggerInterface.js";

/**
 * Enhanced configuration interface for absorption detection - ONLY absorption-specific parameters
 *
 * STANDALONE VERSION: Core interface for enhanced absorption detection
 */
// Use Zod schema inference for complete type safety - matches config.json exactly
export type AbsorptionEnhancedSettings = z.infer<
    typeof AbsorptionDetectorSchema
>;

/**
 * Statistics interface for monitoring absorption detector enhancements
 *
 * STANDALONE VERSION: Comprehensive monitoring and debugging
 */
export interface AbsorptionEnhancementStats {
    // Call statistics
    callCount: number;
    enhancementCount: number;
    errorCount: number;

    // Feature usage statistics
    confluenceDetectionCount: number;
    institutionalDetectionCount: number;
    crossTimeframeAnalysisCount: number;

    // Performance metrics
    averageConfidenceBoost: number;
    totalConfidenceBoost: number;
    enhancementSuccessRate: number;
}

const _BALANCE_CENTER_POINT = 0.5;

/**
 * AbsorptionDetectorEnhanced - Standalone enhanced absorption detector
 *
 * STANDALONE VERSION: CLAUDE.md compliant absorption detection without legacy dependencies
 *
 * This enhanced detector provides sophisticated multi-timeframe absorption analysis using
 * Universal Zones from the preprocessor, with all parameters configurable and no magic numbers.
 */
export class AbsorptionDetectorEnhanced extends Detector {
    private readonly enhancementConfig: AbsorptionEnhancedSettings;
    private readonly enhancementStats: AbsorptionEnhancementStats;
    private readonly preprocessor: IOrderflowPreprocessor;
    private readonly validationLogger: SignalValidationLogger;
    private readonly windowMs: number;

    // Signal cooldown tracking (CLAUDE.md compliance - no magic cooldown values)
    private readonly lastSignal = new Map<string, number>();

    // Dynamic zone tracking for true absorption detection
    private readonly zoneTracker: AbsorptionZoneTracker;

    constructor(
        id: string,
        settings: AbsorptionEnhancedSettings,
        preprocessor: IOrderflowPreprocessor,
        logger: ILogger,
        metrics: IMetricsCollector,
        validationLogger: SignalValidationLogger,
        signalLogger: ISignalLogger
    ) {
        // Settings are pre-validated by Config.ABSORPTION_DETECTOR getter
        // No validation needed here - trust that settings are correct

        // Initialize base detector directly (no legacy inheritance)
        super(id, logger, metrics, signalLogger);

        // Initialize enhancement configuration
        this.enhancementConfig = settings;
        this.preprocessor = preprocessor;
        this.windowMs = Config.getTimeWindow(settings.timeWindowIndex);

        // âœ… SHARED SIGNAL VALIDATION LOGGER: Use dependency-injected shared instance
        this.validationLogger = validationLogger;

        // Initialize enhancement statistics
        this.enhancementStats = {
            callCount: 0,
            enhancementCount: 0,
            errorCount: 0,
            confluenceDetectionCount: 0,
            institutionalDetectionCount: 0,
            crossTimeframeAnalysisCount: 0,
            averageConfidenceBoost: 0,
            totalConfidenceBoost: 0,
            enhancementSuccessRate: 0,
        };

        // Initialize dynamic zone tracking
        const zoneTrackerConfig: AbsorptionTrackerConfig = {
            maxZonesPerSide: settings.maxZonesPerSide,
            historyWindowMs: settings.zoneHistoryWindowMs,
            absorptionThreshold: settings.absorptionZoneThreshold,
            minPassiveVolume: settings.minPassiveVolumeForZone,
            priceStabilityTicks: settings.priceStabilityTicks,
            minAbsorptionEvents: settings.minAbsorptionEvents,
        };
        this.zoneTracker = new AbsorptionZoneTracker(
            zoneTrackerConfig,
            Config.TICK_SIZE
        );

        this.logger.info("AbsorptionDetectorEnhanced initialized", {
            detectorId: id,
            windowMs: this.windowMs,
        });
    }

    /**
     * Main trade event processing - implements required BaseDetector interface
     */
    public onEnrichedTrade(event: EnrichedTradeEvent): void {
        // Update current price for signal validation
        this.validationLogger.updateCurrentPrice(event.price);

        // Only process if standardized zones are enabled and available
        if (!event.zoneData) {
            return;
        }

        this.enhancementStats.callCount++;

        try {
            this.analyzeAbsorptionPattern(event);
        } catch (error) {
            this.enhancementStats.errorCount++;
            this.handleError(
                error instanceof Error ? error : new Error(String(error)),
                "AbsorptionDetectorEnhanced.onEnrichedTrade"
            );
        }
    }

    /**
     * Get detector status - implements required BaseDetector interface
     */
    public getStatus(): string {
        return `Absorption Enhanced - Window: ${this.windowMs}ms`;
    }

    /**
     * Mark signal as confirmed - implements required BaseDetector interface
     */
    public markSignalConfirmed(zone: number, side: "buy" | "sell"): void {
        // Implementation for signal confirmation tracking if needed
        this.logger.debug("AbsorptionDetectorEnhanced: Signal confirmed", {
            detectorId: this.getId(),
            zone,
            side,
        });
    }

    /**
     * Check if we can emit a signal for this detector (respects cooldown)
     */
    private canEmitSignal(eventKey: string, update: boolean = false): boolean {
        // Note: For signal cooldown, we still use Date.now() since it's system time management
        // not market data timing. This is acceptable as per architectural guidelines.
        const now = Date.now();
        const lastSignalTime = this.lastSignal.get(eventKey) || 0;

        if (now - lastSignalTime <= this.enhancementConfig.eventCooldownMs) {
            return false;
        }

        if (update) {
            this.lastSignal.set(eventKey, now);
        }
        return true;
    }

    /**
     * Core absorption pattern analysis using standardized zones
     *
     * STANDALONE VERSION: Complete absorption detection with enhancement analysis
     */
    private analyzeAbsorptionPattern(event: EnrichedTradeEvent): void {
        if (!event.zoneData) {
            return;
        }

        // Update zone tracker with current market data
        // Update spread if available
        if (event.bestBid && event.bestAsk) {
            this.zoneTracker.updateSpread(event.bestBid, event.bestAsk);
        }

        // Update price history for stability tracking
        this.zoneTracker.updatePrice(event.price, event.timestamp);

        // Update zones in tracker
        for (const zone of event.zoneData.zones) {
            this.zoneTracker.updateZone(zone, event.timestamp);
        }

        // STEP 1: CORE ABSORPTION DETECTION (Required for any signals)
        const coreAbsorptionResult = this.detectAbsorption(event);
        if (!coreAbsorptionResult) {
            this.logger.debug(
                "AbsorptionDetectorEnhanced: No core absorption detected - no signals",
                {
                    detectorId: this.getId(),
                    price: event.price,
                    quantity: event.quantity,
                    zoneCount: event.zoneData ? event.zoneData.zones.length : 0,
                }
            );
            return; // No core absorption - no signals at all
        }

        // STEP 2: QUALITY FLAG ANALYSIS (Track signal quality indicators)
        let hasZoneConfluence = false;
        let hasInstitutionalVolume = false;
        let hasCrossTimeframe = false;
        let hasPriceEfficiency = false;

        // Zone confluence analysis for absorption validation (CLAUDE.md compliant)
        const confluenceResult = this.analyzeZoneConfluence(
            event.zoneData,
            event.price
        );

        if (confluenceResult.hasConfluence) {
            hasZoneConfluence = true;
            this.enhancementStats.confluenceDetectionCount++;
        }

        // Institutional absorption analysis across zones
        const absorptionResult = this.analyzeInstitutionalAbsorption(
            event.zoneData,
            event
        );
        if (absorptionResult.hasAbsorption) {
            hasInstitutionalVolume = true;
            this.enhancementStats.institutionalDetectionCount++;
        }

        // Cross-timeframe absorption analysis (CLAUDE.md compliant)
        const crossTimeframeResult: {
            hasAlignment: boolean;
            alignmentScore: number;
            timeframeBreakdown: {
                tick5: number;
                tick10: number;
                tick20: number;
            };
        } = this.analyzeCrossTimeframeAbsorption(event.zoneData, event);
        if (crossTimeframeResult.hasAlignment) {
            hasCrossTimeframe = true;
            this.enhancementStats.crossTimeframeAnalysisCount++;

            this.logger.debug(
                "AbsorptionDetectorEnhanced: Cross-timeframe absorption alignment",
                {
                    detectorId: this.getId(),
                    price: event.price,
                    alignmentScore: crossTimeframeResult.alignmentScore,
                    timeframeBreakdown: crossTimeframeResult.timeframeBreakdown,
                }
            );
        }

        // Check price efficiency from the core signal data
        const signalData =
            coreAbsorptionResult.data as EnhancedAbsorptionSignalData;
        if (
            signalData.priceEfficiency !== null &&
            signalData.priceEfficiency <=
                this.enhancementConfig.priceEfficiencyThreshold
        ) {
            hasPriceEfficiency = true;
        }

        // Determine if any enhancements/quality flags were detected
        const enhancementApplied =
            hasZoneConfluence ||
            hasInstitutionalVolume ||
            hasCrossTimeframe ||
            hasPriceEfficiency;

        // STEP 3: EMIT SINGLE SIGNAL with quality flags
        if (enhancementApplied) {
            // Update enhancement statistics
            this.enhancementStats.enhancementCount++;
            this.enhancementStats.enhancementSuccessRate =
                this.enhancementStats.enhancementCount /
                this.enhancementStats.callCount;

            // Create enhanced signal with quality flags
            const enhancedSignal: SignalCandidate = {
                ...coreAbsorptionResult,
                id: `enhanced-${coreAbsorptionResult.id}`,
                qualityFlags: {
                    crossTimeframe: hasCrossTimeframe,
                    institutionalVolume: hasInstitutionalVolume,
                    zoneConfluence: hasZoneConfluence,
                    priceEfficiency: hasPriceEfficiency,
                },
            };

            // Check signal cooldown to prevent too many signals
            const eventKey = `absorption`; // Single cooldown for all absorption signals
            if (!this.canEmitSignal(eventKey)) {
                this.logger.debug(
                    "AbsorptionDetectorEnhanced: Signal blocked by cooldown",
                    {
                        detectorId: this.getId(),
                        price: event.price,
                        eventKey,
                        cooldownMs: this.enhancementConfig.eventCooldownMs,
                    }
                );
                return;
            }

            // Update cooldown tracking before emitting signal
            this.canEmitSignal(eventKey, true);

            // Log enhanced signal for validation tracking BEFORE checking thresholds

            // Only emit if confidence meets the final confidence requirement
            if (
                coreAbsorptionResult.confidence <
                this.enhancementConfig.finalConfidenceRequired
            ) {
                return; // Signal doesn't meet confidence threshold but was logged
            }

            this.emit("signalCandidate", enhancedSignal);

            this.logger.info(
                "ðŸŽ¯ AbsorptionDetectorEnhanced: ENHANCED ABSORPTION SIGNAL GENERATED!",
                {
                    detectorId: this.getId(),
                    price: event.price,
                    side: enhancedSignal.side,
                    confidence: coreAbsorptionResult.confidence,
                    qualityFlags: enhancedSignal.qualityFlags,
                    signalId: enhancedSignal.id,
                    signalType: "absorption",
                    timestamp: new Date(enhancedSignal.timestamp).toISOString(),
                }
            );
        } else {
            // Add quality flags to core signal
            const signalWithFlags: SignalCandidate = {
                ...coreAbsorptionResult,
                qualityFlags: {
                    crossTimeframe: hasCrossTimeframe,
                    institutionalVolume: hasInstitutionalVolume,
                    zoneConfluence: hasZoneConfluence,
                    priceEfficiency: hasPriceEfficiency,
                },
            };

            // MANDATORY: Zone tracking validation when enabled
            let finalSignal = signalWithFlags;
            const isBuyTrade = !event.buyerIsMaker;
            const absorptionPattern =
                this.zoneTracker.analyzeAbsorption(isBuyTrade);

            // MANDATORY: Zone tracking MUST confirm absorption
            if (
                !absorptionPattern.hasAbsorption ||
                !absorptionPattern.direction
            ) {
                this.logger.info(
                    "Signal BLOCKED: Zone tracking did not confirm absorption",
                    {
                        hasAbsorption: absorptionPattern.hasAbsorption,
                        direction: absorptionPattern.direction,
                        priceStability: absorptionPattern.priceStability,
                        absorptionRatio: absorptionPattern.absorptionRatio,
                        affectedZones: absorptionPattern.affectedZones,
                        minEvents:
                            this.zoneTracker.getConfig().minAbsorptionEvents,
                    }
                );
                return; // BLOCK signal if zone tracking doesn't confirm
            }

            // MANDATORY: Price stability check
            if (!absorptionPattern.priceStability) {
                this.logger.info(
                    "Signal BLOCKED: Price not stable during absorption",
                    {
                        priceStability: absorptionPattern.priceStability,
                        priceStabilityTicks:
                            this.zoneTracker.getConfig().priceStabilityTicks,
                    }
                );
                return; // BLOCK signal if price isn't stable
            }

            // Zone tracking confirmed - use its direction and confidence
            const enhancedData =
                signalWithFlags.data as EnhancedAbsorptionSignalData;
            finalSignal = {
                ...signalWithFlags,
                side: absorptionPattern.direction,
                confidence: Math.max(
                    signalWithFlags.confidence,
                    absorptionPattern.confidence
                ),
                data: {
                    ...enhancedData,
                    metadata: {
                        ...enhancedData.metadata,
                        absorptionPattern: {
                            type: absorptionPattern.absorptionType,
                            ratio: absorptionPattern.absorptionRatio,
                            strength: absorptionPattern.absorptionStrength,
                            affectedZones: absorptionPattern.affectedZones,
                            priceStability: absorptionPattern.priceStability,
                        },
                    },
                } as EnhancedAbsorptionSignalData,
            };

            this.logger.info("Zone tracking CONFIRMED absorption signal", {
                absorptionType: absorptionPattern.absorptionType,
                direction: absorptionPattern.direction,
                ratio: absorptionPattern.absorptionRatio,
                confidence: absorptionPattern.confidence,
                priceStability: absorptionPattern.priceStability,
            });

            // Update cooldown tracking before emitting signal
            // this.canEmitSignal(eventKey, true);

            // Only check threshold AFTER logging
            if (
                finalSignal.confidence <
                this.enhancementConfig.finalConfidenceRequired
            ) {
                return; // Signal doesn't meet final confidence threshold but was logged
            }

            this.emit("signalCandidate", finalSignal);

            this.logger.info(
                "ðŸŽ¯ AbsorptionDetectorEnhanced: CORE ABSORPTION SIGNAL GENERATED!",
                {
                    detectorId: this.getId(),
                    price: event.price,
                    side: signalWithFlags.side,
                    confidence: coreAbsorptionResult.confidence,
                    signalId: coreAbsorptionResult.id,
                    signalType: "absorption",
                    timestamp: new Date(
                        coreAbsorptionResult.timestamp
                    ).toISOString(),
                }
            );
        }
    }

    /**
     * Core absorption detection logic with FinancialMath compliance
     *
     * INSTITUTIONAL GRADE: Complete absorption detection using standardized zones
     * ARCHITECTURAL PATTERN: Follows successful exhaustion detector restructuring
     */
    private detectAbsorption(
        event: EnrichedTradeEvent
    ): SignalCandidate | null {
        // EARLY VALIDATION: Only check for missing/malformed data - no signal validation logging
        if (!event.zoneData) {
            this.logger.debug(
                "[AbsorptionDetectorEnhanced] No zone data available"
            );
            return null;
        }
        const allZones = [...event.zoneData.zones];
        if (allZones.length === 0) {
            return null;
        }

        // Filter zones by time window using trade timestamp
        const windowStartTime = event.timestamp - this.windowMs;
        const recentZones = allZones.filter(
            (zone) => zone.lastUpdate >= windowStartTime
        );

        // Find zones near the current price from recent zones only
        // confluenceMaxDistance: [CONSTANT]: this.enhancementConfig.confluenceMaxDistance ==> filter relevantZones,
        const relevantZones = this.preprocessor.findZonesNearPrice(
            recentZones,
            event.price,
            this.enhancementConfig.confluenceMaxDistance
        );
        if (relevantZones.length === 0) {
            return null;
        }

        // directionalAggressive , directionalPassive , totalPressure, pressureRatio
        const volumePressure = this.calculateVolumePressure(
            event,
            relevantZones
        );
        if (!volumePressure) {
            return null;
        }

        // minAggVolume: directionalAggressive >= this.enhancementConfig.minAggVolume
        const directionalAggressive = volumePressure.aggressivePressure;
        const passesVolumeThreshold =
            directionalAggressive >= this.enhancementConfig.minAggVolume;

        // Calculate passive volume ratio for institutional absorption
        // passiveAbsorptionThreshold: passiveVolumeRatio >= this.enhancementConfig.passiveAbsorptionThreshold
        const passiveVolumeRatio = FinancialMath.divideQuantities(
            volumePressure.passivePressure,
            volumePressure.totalPressure
        );
        const passesPassiveRatioThreshold =
            passiveVolumeRatio >=
            this.enhancementConfig.passiveAbsorptionThreshold;

        // Calculate price efficiency using FinancialMath (institutional precision)
        // priceEfficiencyThreshold: priceEfficiency <= this.enhancementConfig.priceEfficiencyThreshold
        const priceEfficiency = this.calculatePriceEfficiency(
            event,
            relevantZones
        );
        const passesEfficiencyThreshold =
            priceEfficiency <= this.enhancementConfig.priceEfficiencyThreshold;

        // Calculate absorption ratio using FinancialMath
        // maxAbsorptionRatio: // Check: absorptionRatio <= this.enhancementConfig.maxAbsorptionRatio
        const absorptionRatio = this.calculateAbsorptionRatio(
            event,
            volumePressure
        );
        const passesAbsorptionRatioThreshold =
            absorptionRatio !== null &&
            absorptionRatio <= this.enhancementConfig.maxAbsorptionRatio;

        // Check passive multiplier (passive must be X times aggressive)
        // minPassiveMultiplier: Check: actualPassiveMultiplier >= this.enhancementConfig.minPassiveMultiplier,
        const directionalPassive = volumePressure.passivePressure;
        const actualPassiveMultiplier =
            directionalAggressive > 0
                ? FinancialMath.divideQuantities(
                      directionalPassive,
                      directionalAggressive
                  )
                : 0;
        const passesPassiveMultiplierThreshold =
            actualPassiveMultiplier >=
            this.enhancementConfig.minPassiveMultiplier;

        // Calculate final confidence using statistical analysis
        // finalConfidenceRequired:  Check: confidence >= this.enhancementConfig.finalConfidenceRequired
        const confidence =
            priceEfficiency !== null &&
            absorptionRatio !== null &&
            volumePressure !== null
                ? this.calculateAbsorptionConfidence(
                      priceEfficiency,
                      absorptionRatio,
                      volumePressure,
                      relevantZones
                  )
                : null;
        const passesConfidenceThreshold =
            confidence !== null &&
            confidence >= this.enhancementConfig.finalConfidenceRequired;

        const minAbsorptionScore =
            directionalPassive > 0
                ? FinancialMath.divideQuantities(
                      directionalPassive,
                      FinancialMath.safeAdd(
                          directionalAggressive,
                          directionalPassive
                      )
                  )
                : 0;
        const passesMinAbsorptionScoreThreshold =
            minAbsorptionScore >= this.enhancementConfig.minAbsorptionScore;

        let totalAggressiveBuy = 0;
        let totalAggressiveSell = 0;
        let totalPassiveBuy = 0;
        let totalPassiveSell = 0;

        for (const zone of relevantZones) {
            totalAggressiveBuy += zone.aggressiveBuyVolume || 0;
            totalAggressiveSell += zone.aggressiveSellVolume || 0;
            totalPassiveBuy += zone.passiveBidVolume || 0;
            totalPassiveSell += zone.passiveAskVolume || 0;
        }

        const totalAggressive = FinancialMath.safeAdd(
            totalAggressiveBuy,
            totalAggressiveSell
        );
        const totalPassive = FinancialMath.safeAdd(
            totalPassiveBuy,
            totalPassiveSell
        );

        if (totalAggressive === 0 || totalPassive === 0) return null;

        // Calculate balance ratios using FinancialMath
        const aggressiveBuyRatio = FinancialMath.divideQuantities(
            totalAggressiveBuy,
            totalAggressive
        );
        const passiveBuyRatio = FinancialMath.divideQuantities(
            totalPassiveBuy,
            totalPassive
        );

        // Check for balanced flow (both ratios close to 0.5)
        const aggressiveBalance = FinancialMath.calculateAbs(
            FinancialMath.safeSubtract(
                aggressiveBuyRatio,
                _BALANCE_CENTER_POINT
            )
        );
        const passiveBalance = FinancialMath.calculateAbs(
            FinancialMath.safeSubtract(passiveBuyRatio, _BALANCE_CENTER_POINT)
        );
        const passesBalanceThreshold =
            aggressiveBalance <= this.enhancementConfig.balanceThreshold &&
            passiveBalance <= this.enhancementConfig.balanceThreshold;

        // Calculate actual price movement in ticks from zones
        const priceMovementTicks =
            relevantZones.length > 0 && relevantZones[0]
                ? Math.abs(event.price - relevantZones[0].priceLevel) /
                  Config.TICK_SIZE
                : 0;

        // âœ… BUILD THRESHOLD CHECKS: Complete set with threshold, calculated, and operator
        const thresholdChecks: AbsorptionThresholdChecks = {
            // [CONSTANT]: this.enhancementConfig.confluenceMaxDistance ==> filter relevantZones
            confluenceMaxDistance: {
                threshold: this.enhancementConfig.confluenceMaxDistance,
                calculated: this.enhancementConfig.confluenceMaxDistance,
                op: "NONE",
            },

            // [CONSTANT] this.enhancementConfig.maxZoneCountForScoring
            maxZoneCountForScoring: {
                threshold: this.enhancementConfig.maxZoneCountForScoring,
                calculated: this.enhancementConfig.maxZoneCountForScoring,
                op: "NONE", // Used for scoring calculation, not checked
            },

            // [CONSTANT] this.enhancementConfig.eventCooldownMs
            eventCooldownMs: {
                threshold: this.enhancementConfig.eventCooldownMs,
                calculated: this.enhancementConfig.eventCooldownMs,
                op: "NONE", // Cooldown is handled separately
            },

            // [CONSTANT] this.enhancementConfig.timeWindowIndex
            timeWindowIndex: {
                threshold: this.enhancementConfig.timeWindowIndex,
                calculated: this.enhancementConfig.timeWindowIndex,
                op: "NONE", // Not actively checked
            },

            // [CONSTANT] this.enhancementConfig.expectedMovementScalingFactor
            expectedMovementScalingFactor: {
                threshold: this.enhancementConfig.expectedMovementScalingFactor,
                calculated:
                    this.enhancementConfig.expectedMovementScalingFactor,
                op: "NONE", // Used for calculations, not checked
            },

            // [CONSTANT] this.enhancementConfig.confluenceMinZones,
            confluenceMinZones: {
                threshold: this.enhancementConfig.confluenceMinZones,
                calculated: this.enhancementConfig.confluenceMinZones,
                op: "NONE", // Zone confluence is evaluated differently
            },

            // [zoneTrackerConfig] this.enhancementConfig.maxZonesPerSide
            maxZonesPerSide: {
                threshold: this.enhancementConfig.maxZonesPerSide,
                calculated: this.enhancementConfig.maxZonesPerSide,
                op: "NONE", // Zone count limit, handled by zone tracker
            },

            // [zoneTrackerConfig] this.enhancementConfig.zoneHistoryWindowMs
            zoneHistoryWindowMs: {
                threshold: this.enhancementConfig.zoneHistoryWindowMs,
                calculated: this.enhancementConfig.zoneHistoryWindowMs,
                op: "NONE", // Window configuration, not checked
            },

            // [zoneTrackerConfig] this.enhancementConfig.absorptionZoneThreshold
            absorptionZoneThreshold: {
                threshold: this.enhancementConfig.absorptionZoneThreshold,
                calculated: absorptionRatio ?? 0,
                op: "NONE", // Absorption ratio already checked via maxAbsorptionRatio
            },

            // [zoneTrackerConfig] this.enhancementConfig.priceStabilityTicks
            priceStabilityTicks: {
                threshold: this.enhancementConfig.priceStabilityTicks,
                calculated: priceMovementTicks,
                op: "NONE", // Used for stability analysis, not directly checked
            },

            // [zoneTrackerConfig] this.enhancementConfig.minPassiveVolumeForZone
            minPassiveVolumeForZone: {
                threshold: this.enhancementConfig.minPassiveVolumeForZone,
                calculated: this.enhancementConfig.minPassiveVolumeForZone,
                op: "NONE", // Window configuration, not checked
            },

            // [zoneTrackerConfig] this.enhancementConfig.minAbsorptionEvents
            minAbsorptionEvents: {
                threshold: this.enhancementConfig.minAbsorptionEvents,
                calculated: this.enhancementConfig.minAbsorptionEvents,
                op: "NONE", // Window configuration, not checked
            },

            minAggVolume: {
                threshold: this.enhancementConfig.minAggVolume,
                calculated: directionalAggressive,
                op: "EQL", // Check: directionalAggressive >= this.enhancementConfig.minAggVolume
            },

            passiveAbsorptionThreshold: {
                threshold: this.enhancementConfig.passiveAbsorptionThreshold,
                calculated: passiveVolumeRatio,
                op: "EQL", // Check: passiveVolumeRatio >= this.enhancementConfig.passiveAbsorptionThreshold
            },

            priceEfficiencyThreshold: {
                threshold: this.enhancementConfig.priceEfficiencyThreshold,
                calculated: priceEfficiency,
                op: "EQS", // Check: priceEfficiency <= threshold
            },

            maxAbsorptionRatio: {
                threshold: this.enhancementConfig.maxAbsorptionRatio,
                calculated: absorptionRatio ?? 0,
                op: "EQS", // Check: absorptionRatio <= threshold
            },

            minPassiveMultiplier: {
                threshold: this.enhancementConfig.minPassiveMultiplier,
                calculated: actualPassiveMultiplier,
                op: "EQL", // Check: actualPassiveMultiplier >= threshold
            },

            finalConfidenceRequired: {
                threshold: this.enhancementConfig.finalConfidenceRequired,
                calculated: confidence ?? 0,
                op: "EQL",
            },

            minAbsorptionScore: {
                threshold: this.enhancementConfig.minAbsorptionScore,
                calculated: minAbsorptionScore,
                op: "EQL",
            },

            balanceThreshold: {
                threshold: this.enhancementConfig.balanceThreshold,
                calculated: Math.max(
                    Math.abs(
                        directionalAggressive /
                            Math.max(
                                directionalAggressive + directionalPassive,
                                1
                            ) -
                            _BALANCE_CENTER_POINT
                    ),
                    Math.abs(
                        directionalPassive /
                            Math.max(
                                directionalAggressive + directionalPassive,
                                1
                            ) -
                            _BALANCE_CENTER_POINT
                    )
                ),
                op: "EQL", // Used for balance detection, specific check logic
            },
        };

        // Determine dominant side and signal direction
        const dominantSide = this.calculateDominantSide(relevantZones, event);

        this.logger.debug(
            "AbsorptionDetectorEnhanced: All calculations completed",
            {
                directionalAggressive,
                directionalPassive,
                passiveVolumeRatio,
                priceEfficiency,
                absorptionRatio,
                confidence,
                dominantSide,
                thresholdChecks,
            }
        );

        const hasValidSignalSide = dominantSide !== null;

        // Comprehensive rejection with complete threshold data
        if (
            !passesVolumeThreshold ||
            !passesPassiveRatioThreshold ||
            !passesEfficiencyThreshold ||
            !passesAbsorptionRatioThreshold ||
            !passesConfidenceThreshold ||
            !passesMinAbsorptionScoreThreshold ||
            !hasValidSignalSide ||
            !passesBalanceThreshold
        ) {
            // Determine primary rejection reason for logging
            let rejectionReason = "comprehensive_rejection";
            let thresholdType = "multiple_thresholds";
            let thresholdValue = 0;
            let actualValue = 0;

            if (!passesVolumeThreshold) {
                rejectionReason = "insufficient_aggressive_volume";
                thresholdType = "aggressive_volume";
                thresholdValue = this.enhancementConfig.minAggVolume;
                actualValue = directionalAggressive;
            } else if (!passesPassiveRatioThreshold) {
                rejectionReason = "passive_volume_ratio_too_low";
                thresholdType = "passive_volume_ratio";
                thresholdValue =
                    this.enhancementConfig.passiveAbsorptionThreshold;
                actualValue = passiveVolumeRatio;
            } else if (!passesEfficiencyThreshold) {
                rejectionReason = "price_efficiency_too_high";
                thresholdType = "price_efficiency";
                thresholdValue =
                    this.enhancementConfig.priceEfficiencyThreshold;
                actualValue = priceEfficiency ?? -1;
            } else if (!passesAbsorptionRatioThreshold) {
                rejectionReason = "absorption_ratio_too_high";
                thresholdType = "absorption_ratio";
                thresholdValue = this.enhancementConfig.maxAbsorptionRatio;
                actualValue = absorptionRatio ?? -1;
            } else if (!passesPassiveMultiplierThreshold) {
                rejectionReason = "passive_multiplier_too_low";
                thresholdType = "passive_multiplier";
                thresholdValue = this.enhancementConfig.minPassiveMultiplier;
                actualValue = actualPassiveMultiplier ?? -1;
            } else if (!passesConfidenceThreshold) {
                rejectionReason = "confidence_below_threshold";
                thresholdType = "confidence_threshold";
                thresholdValue = this.enhancementConfig.finalConfidenceRequired;
                actualValue = confidence ?? 0;
            } else if (!hasValidSignalSide) {
                rejectionReason = "no_dominant_side";
                thresholdType = "side_determination";
                thresholdValue = 1;
                actualValue = 0;
            } else if (!passesBalanceThreshold) {
                rejectionReason = "balanced_institutional_flow";
                thresholdType = "institutional_balance";
                thresholdValue = this.enhancementConfig.balanceThreshold;
                actualValue = 0;
            }

            this.logSignalRejection(
                event,
                rejectionReason,
                {
                    type: thresholdType,
                    threshold: thresholdValue,
                    actual: actualValue,
                },
                thresholdChecks
            );
            return null;
        }

        // Create signal candidate with correct interface structure
        const signalCandidate: SignalCandidate = {
            id: `absorption-${this.getId()}-${event.timestamp}`,
            type: "absorption" as SignalType,
            side: dominantSide, // Follow institutional flow direction
            confidence,
            timestamp: event.timestamp,
            data: {
                price: event.price,
                zone: event.price, // Use price as zone for now
                side: dominantSide,
                aggressive: volumePressure.aggressivePressure,
                passive: volumePressure.passivePressure,
                refilled: false, // Will be determined later
                confidence,
                absorptionScore: 1 - absorptionRatio, // Invert ratio for score
                passiveMultiplier: this.enhancementConfig.minPassiveMultiplier,
                priceEfficiency,
                spreadImpact:
                    event.bestAsk !== undefined && event.bestBid !== undefined
                        ? FinancialMath.calculateSpread(
                              event.bestAsk,
                              event.bestBid,
                              2
                          )
                        : 0,
                volumeProfile: {
                    totalVolume: volumePressure.totalPressure,
                    institutionalRatio: volumePressure.pressureRatio,
                },
                metadata: {
                    signalType: "absorption",
                    timestamp: event.timestamp,
                    institutionalRatio: volumePressure.pressureRatio,
                    enhancementType: "standalone_enhanced",
                },
            } as EnhancedAbsorptionSignalData,
        };

        const signalZones = event.zoneData ? event.zoneData.zones : [];

        this.logSignalForValidation(
            signalCandidate,
            event,
            signalZones,
            thresholdChecks
        );
        void this.logSuccessfulSignalParameters(
            signalCandidate,
            event,
            thresholdChecks
        );
        return signalCandidate;
    }

    /**
     * Calculate volume pressure using FinancialMath for institutional precision
     * DIRECTIONAL FIX: Only count passive volume relevant to trade direction
     */
    private calculateVolumePressure(
        event: EnrichedTradeEvent,
        zones: ZoneSnapshot[]
    ): {
        aggressivePressure: number;
        passivePressure: number;
        totalPressure: number;
        pressureRatio: number;
    } | null {
        if (zones.length === 0) return null;

        // Calculate total aggressive volume using FinancialMath.safeAdd
        let totalAggressive = 0;
        let totalPassive = 0;

        // CRITICAL FIX: Determine which passive volume is relevant based on trade direction
        // - Buy trades (buyerIsMaker = false): Only count passiveAskVolume (hitting asks)
        // - Sell trades (buyerIsMaker = true): Only count passiveBidVolume (hitting bids)
        const isBuyTrade = !event.buyerIsMaker;

        for (const zone of zones) {
            // Get directional volumes
            const directionalAggressive = isBuyTrade
                ? (zone.aggressiveBuyVolume ?? 0) // Buy trades: only aggressive buying affects asks
                : (zone.aggressiveSellVolume ?? 0); // Sell trades: only aggressive selling affects bids
            const directionalPassive = isBuyTrade
                ? (zone.passiveAskVolume ?? 0) // Buy trades absorb ask liquidity
                : (zone.passiveBidVolume ?? 0); // Sell trades absorb bid liquidity

            // Validate inputs before FinancialMath calls to prevent NaN BigInt errors
            if (isNaN(directionalAggressive) || isNaN(directionalPassive)) {
                return null; // Skip this calculation if any zone has NaN values
            }

            totalAggressive = FinancialMath.safeAdd(
                totalAggressive,
                directionalAggressive
            );

            // DIRECTIONAL PASSIVE VOLUME: Add the relevant passive volume already calculated
            totalPassive = FinancialMath.safeAdd(
                totalPassive,
                directionalPassive
            );
        }

        if (totalPassive === 0) return null; // Prevent division by zero

        // Calculate pressure ratio using FinancialMath.divideQuantities
        const pressureRatio = FinancialMath.divideQuantities(
            totalAggressive,
            totalPassive
        );
        const totalPressure = FinancialMath.safeAdd(
            totalAggressive,
            totalPassive
        );

        return {
            aggressivePressure: totalAggressive,
            passivePressure: totalPassive,
            totalPressure,
            pressureRatio,
        };
    }

    /**
     * Calculate price efficiency using FinancialMath (institutional compliance)
     */
    private calculatePriceEfficiency(
        event: EnrichedTradeEvent,
        zones: ZoneSnapshot[]
    ): number {
        // DEBUG: Log zone VWAP status
        this.logger.info(
            "AbsorptionDetectorEnhanced: calculatePriceEfficiency zones",
            {
                totalZones: zones.length,
                zonesWithVWAP: zones.filter(
                    (z) => z.volumeWeightedPrice !== null
                ).length,
                zonesWithVolume: zones.filter((z) => z.aggressiveVolume > 0)
                    .length,
                sampleZones: zones.slice(0, 3).map((z) => ({
                    priceLevel: z.priceLevel,
                    volumeWeightedPrice: z.volumeWeightedPrice,
                    aggressiveVolume: z.aggressiveVolume,
                })),
            }
        );

        // Calculate volume-weighted average price using FinancialMath
        let totalVolumeWeightedPrice = 0;
        let totalVolume = 0;

        for (const zone of zones) {
            // CRITICAL: Check for both null and undefined, and skip zones with invalid data
            if (
                zone.volumeWeightedPrice == null ||
                isNaN(zone.volumeWeightedPrice)
            )
                continue;
            if (zone.aggressiveVolume == null || isNaN(zone.aggressiveVolume))
                continue;

            const zoneWeight = FinancialMath.multiplyQuantities(
                zone.volumeWeightedPrice,
                zone.aggressiveVolume
            );

            // Skip zones where calculation fails
            if (isNaN(zoneWeight)) continue;

            totalVolumeWeightedPrice = FinancialMath.safeAdd(
                totalVolumeWeightedPrice,
                zoneWeight
            );
            totalVolume = FinancialMath.safeAdd(
                totalVolume,
                zone.aggressiveVolume
            );
        }

        // DEBUG: Log calculation status
        this.logger.info(
            "AbsorptionDetectorEnhanced: Price efficiency calculation",
            {
                totalVolumeWeightedPrice,
                totalVolume,
                willReturnNull: totalVolume === 0,
            }
        );

        if (totalVolume === 0) return 0;

        const vwap = FinancialMath.divideQuantities(
            totalVolumeWeightedPrice,
            totalVolume
        );
        const priceDiff = FinancialMath.calculateAbs(
            FinancialMath.safeSubtract(event.price, vwap)
        );

        // Calculate efficiency as percentage using FinancialMath
        return FinancialMath.divideQuantities(priceDiff, event.price);
    }

    /**
     * Calculate absorption ratio using FinancialMath precision
     */
    private calculateAbsorptionRatio(
        event: EnrichedTradeEvent,
        volumePressure: {
            aggressivePressure: number;
            passivePressure: number;
            totalPressure: number;
            pressureRatio: number;
        }
    ): number | null {
        const expectedMovement = FinancialMath.multiplyQuantities(
            event.quantity,
            this.enhancementConfig.expectedMovementScalingFactor
        );

        if (expectedMovement === 0) return null;

        // Calculate absorption using volume pressure and price impact
        if (event.bestBid === undefined) return null; // Cannot calculate without bid price
        const actualImpact = FinancialMath.calculateAbs(
            FinancialMath.safeSubtract(event.price, event.bestBid)
        );

        // Factor in volume pressure for more accurate absorption calculation
        const pressureAdjustedImpact = FinancialMath.multiplyQuantities(
            actualImpact,
            volumePressure.pressureRatio
        );

        return FinancialMath.divideQuantities(
            pressureAdjustedImpact,
            expectedMovement
        );
    }

    /**
     * Calculate dominant side based on directional passive volume absorption
     * CRITICAL: Determines signal direction based on institutional flow
     * FIXED: Now uses same directional logic as calculateVolumePressure
     */
    private calculateDominantSide(
        zones: ZoneSnapshot[],
        event: EnrichedTradeEvent
    ): "buy" | "sell" | null {
        if (zones.length === 0) return null;

        // CRITICAL FIX: Use same directional logic as calculateVolumePressure
        // - Buy trades (buyerIsMaker = false): Only count passiveAskVolume (hitting asks)
        // - Sell trades (buyerIsMaker = true): Only count passiveBidVolume (hitting bids)
        const isBuyTrade = !event.buyerIsMaker;

        let relevantPassiveVolume = 0;

        for (const zone of zones) {
            // DIRECTIONAL PASSIVE VOLUME: Only count relevant side matching the trade
            const zoneRelevantVolume = isBuyTrade
                ? zone.passiveAskVolume || 0 // Buy trades absorb ask liquidity
                : zone.passiveBidVolume || 0; // Sell trades absorb bid liquidity

            relevantPassiveVolume = FinancialMath.safeAdd(
                relevantPassiveVolume,
                zoneRelevantVolume
            );
        }

        // DEBUG: Log directional passive volume calculations
        this.logger.info(
            "AbsorptionDetectorEnhanced: calculateDominantSide DIRECTIONAL DEBUG",
            {
                isBuyTrade,
                buyerIsMaker: event.buyerIsMaker,
                relevantPassiveVolume,
                zoneCount: zones.length,
                tradeDirection: isBuyTrade ? "BUY" : "SELL",
                passiveSideUsed: isBuyTrade ? "ask" : "bid",
            }
        );

        // DIRECTIONAL SIGNAL LOGIC: Signal follows the trade direction that shows absorption
        // This aligns with calculateVolumePressure which also uses directional passive volume
        if (relevantPassiveVolume > 0) {
            const signalSide = isBuyTrade ? "buy" : "sell";
            this.logger.info(
                `AbsorptionDetectorEnhanced: Returning ${signalSide.toUpperCase()} signal (directional absorption detected)`,
                {
                    relevantPassiveVolume,
                    tradeDirection: isBuyTrade ? "BUY" : "SELL",
                    signalSide,
                }
            );
            return signalSide;
        }

        this.logger.info(
            "AbsorptionDetectorEnhanced: Returning NULL (no directional absorption)",
            {
                relevantPassiveVolume,
                tradeDirection: isBuyTrade ? "BUY" : "SELL",
            }
        );
        return null; // No directional absorption
    }

    /**
     * Calculate final absorption confidence using statistical analysis
     */
    private calculateAbsorptionConfidence(
        priceEfficiency: number,
        absorptionRatio: number,
        volumePressure: { pressureRatio: number },
        zones: ZoneSnapshot[]
    ): number | null {
        // Validate inputs before creating confidence factors
        if (
            !FinancialMath.isValidFinancialNumber(priceEfficiency) ||
            !FinancialMath.isValidFinancialNumber(absorptionRatio) ||
            !FinancialMath.isValidFinancialNumber(volumePressure.pressureRatio)
        ) {
            return null; // Cannot calculate confidence with invalid inputs
        }

        // Calculate confidence factors using FinancialMath (CLAUDE.md compliance - no bounds forcing)
        const efficiencyFactor = 1 - priceEfficiency; // Higher efficiency = higher confidence
        const absorptionFactor = 1 - absorptionRatio; // Lower absorption ratio = higher confidence
        const pressureFactor = FinancialMath.divideQuantities(
            volumePressure.pressureRatio,
            2
        ); // Pressure component
        const zoneFactor = FinancialMath.divideQuantities(
            zones.length,
            this.enhancementConfig.maxZoneCountForScoring
        ); // Zone count component

        // Validate all factors before proceeding (CLAUDE.md compliance - return null for invalid calculations)
        if (
            !FinancialMath.isValidFinancialNumber(efficiencyFactor) ||
            !FinancialMath.isValidFinancialNumber(absorptionFactor) ||
            !FinancialMath.isValidFinancialNumber(pressureFactor) ||
            !FinancialMath.isValidFinancialNumber(zoneFactor) ||
            efficiencyFactor < 0 ||
            absorptionFactor < 0 ||
            pressureFactor < 0 ||
            zoneFactor < 0
        ) {
            return null; // Cannot calculate confidence with invalid factor inputs
        }

        const confidenceFactors = [
            efficiencyFactor,
            absorptionFactor,
            pressureFactor,
            zoneFactor,
        ];

        // Use FinancialMath.calculateMean for statistical precision
        const baseConfidence = FinancialMath.calculateMean(confidenceFactors);

        if (baseConfidence === null) return null; // CLAUDE.md compliance: cannot calculate confidence with invalid data

        // Return the calculated confidence without scaling
        return baseConfidence;
    }

    /**
     * Analyze zone confluence for absorption pattern validation
     *
     * STANDALONE VERSION: Multi-timeframe confluence analysis
     */
    private analyzeZoneConfluence(
        zoneData: StandardZoneData,
        price: number
    ): {
        hasConfluence: boolean;
        confluenceZones: number;
        confluenceStrength: number;
    } {
        const minConfluenceZones = this.enhancementConfig.confluenceMinZones;
        const maxDistance = this.enhancementConfig.confluenceMaxDistance;

        // Find zones that overlap around the current price
        const relevantZones: ZoneSnapshot[] = [];

        // Check 5-tick zones - using universal zone analysis service
        relevantZones.push(
            ...this.preprocessor.findZonesNearPrice(
                zoneData.zones,
                price,
                maxDistance
            )
        );

        // Check 10-tick zones - using universal zone analysis service
        relevantZones.push(
            ...this.preprocessor.findZonesNearPrice(
                zoneData.zones,
                price,
                maxDistance
            )
        );

        // Check 20-tick zones - using universal zone analysis service
        relevantZones.push(
            ...this.preprocessor.findZonesNearPrice(
                zoneData.zones,
                price,
                maxDistance
            )
        );

        const confluenceZones = relevantZones.length;
        const hasConfluence = confluenceZones >= minConfluenceZones;

        // Calculate confluence strength using FinancialMath (higher = more zones overlapping)
        const confluenceStrength = Math.min(
            1.0,
            FinancialMath.divideQuantities(
                confluenceZones,
                minConfluenceZones * 2
            )
        );

        return {
            hasConfluence,
            confluenceZones,
            confluenceStrength,
        };
    }

    /**
     * Analyze institutional absorption across standardized zones
     *
     * STANDALONE VERSION: Enhanced absorption detection
     */
    private analyzeInstitutionalAbsorption(
        zoneData: StandardZoneData,
        event: EnrichedTradeEvent
    ): {
        hasAbsorption: boolean;
        absorptionRatio: number;
        affectedZones: number;
    } {
        const absorptionThreshold =
            this.enhancementConfig.passiveAbsorptionThreshold;
        const minRatio = this.enhancementConfig.passiveAbsorptionThreshold;

        // Analyze all zones for institutional absorption patterns
        const allZones = zoneData.zones;

        const relevantZones = this.preprocessor.findZonesNearPrice(
            allZones,
            event.price,
            this.enhancementConfig.confluenceMaxDistance
        );

        let totalPassiveVolume = 0;
        let totalAggressiveVolume = 0;
        let affectedZones = 0;

        relevantZones.forEach((zone) => {
            const passiveVolume = zone.passiveVolume;
            const aggressiveVolume = zone.aggressiveVolume;

            totalPassiveVolume = FinancialMath.safeAdd(
                totalPassiveVolume,
                passiveVolume
            );
            totalAggressiveVolume = FinancialMath.safeAdd(
                totalAggressiveVolume,
                aggressiveVolume
            );

            // Check if this zone shows absorption (high passive volume absorbing aggressive flow)
            if (
                passiveVolume >= absorptionThreshold &&
                passiveVolume >
                    FinancialMath.multiplyQuantities(
                        aggressiveVolume,
                        this.enhancementConfig.minPassiveMultiplier
                    )
            ) {
                affectedZones++;
            }
        });

        const totalVolume = FinancialMath.safeAdd(
            totalPassiveVolume,
            totalAggressiveVolume
        );
        const absorptionRatio =
            totalVolume > 0
                ? FinancialMath.divideQuantities(
                      totalPassiveVolume,
                      totalVolume
                  )
                : 0;
        const hasAbsorption = absorptionRatio >= minRatio && affectedZones > 0;

        return {
            hasAbsorption,
            absorptionRatio,
            affectedZones,
        };
    }

    /**
     * Analyze cross-timeframe absorption patterns
     *
     * STANDALONE VERSION: Multi-timeframe alignment analysis
     */
    private analyzeCrossTimeframeAbsorption(
        zoneData: StandardZoneData,
        event: EnrichedTradeEvent
    ): {
        hasAlignment: boolean;
        alignmentScore: number;
        timeframeBreakdown: {
            tick5: number;
            tick10: number;
            tick20: number;
        };
    } {
        // CLAUDE.md SIMPLIFIED: Calculate absorption strength for single zone size with temporal filtering
        const absorptionStrength = this.calculateTimeframeAbsorptionStrength(
            zoneData.zones,
            event.price,
            event.timestamp
        );

        // CLAUDE.md compliance: return early if calculation fails
        if (absorptionStrength === null) {
            return {
                hasAlignment: false,
                alignmentScore: 0,
                timeframeBreakdown: {
                    tick5: 0,
                    tick10: 0,
                    tick20: 0,
                },
            }; // CLAUDE.md compliance: return default when calculation cannot be performed
        }

        const timeframeBreakdown = {
            tick5: absorptionStrength,
            tick10: absorptionStrength,
            tick20: absorptionStrength,
        };

        // Calculate alignment score using FinancialMath (how similar absorption levels are across timeframes)
        const absorptionValues = [absorptionStrength];
        const avgAbsorption = FinancialMath.calculateMean(absorptionValues);
        if (avgAbsorption === null) {
            return {
                hasAlignment: false,
                alignmentScore: 0,
                timeframeBreakdown,
            }; // CLAUDE.md compliance: return default when calculation cannot be performed
        }

        const stdDev = FinancialMath.calculateStdDev(absorptionValues);
        if (stdDev === null) {
            return {
                hasAlignment: false,
                alignmentScore: 0,
                timeframeBreakdown,
            }; // CLAUDE.md compliance: return default when calculation cannot be performed
        }

        const variance = FinancialMath.multiplyQuantities(stdDev, stdDev); // Variance = stdDev^2
        const alignmentScore = FinancialMath.multiplyQuantities(
            avgAbsorption,
            Math.max(0, 1 - variance)
        ); // Penalize high variance
        const hasAlignment =
            alignmentScore >= this.enhancementConfig.passiveAbsorptionThreshold; // Require strong alignment for absorption

        return {
            hasAlignment,
            alignmentScore,
            timeframeBreakdown,
        };
    }

    /**
     * Calculate absorption strength for a specific timeframe
     *
     * STANDALONE VERSION: Timeframe-specific analysis
     */
    private calculateTimeframeAbsorptionStrength(
        zones: ZoneSnapshot[],
        price: number,
        tradeTimestamp: number
    ): number | null {
        if (zones.length === 0) return null;

        // CRITICAL FIX: Filter zones by time window using trade timestamp for temporal absorption analysis
        const windowStartTime = tradeTimestamp - this.windowMs;

        const recentZones = zones.filter(
            (zone) => zone.lastUpdate >= windowStartTime
        );

        this.logger.debug("Absorption temporal filtering", {
            totalZones: zones.length,
            recentZones: recentZones.length,
            windowMs: this.windowMs,
            windowStartTime,
            tradeTimestamp,
        });

        if (recentZones.length === 0) return null;

        const relevantZones = this.preprocessor.findZonesNearPrice(
            recentZones,
            price,
            this.enhancementConfig.confluenceMaxDistance
        );
        if (relevantZones.length === 0) return null;

        let totalAbsorptionScore = 0;

        for (const zone of relevantZones) {
            const totalVolume = FinancialMath.safeAdd(
                zone.aggressiveVolume,
                zone.passiveVolume
            );
            if (totalVolume === 0) continue;

            // For absorption, we want high passive volume absorbing aggressive flow using FinancialMath
            const passiveRatio = FinancialMath.divideQuantities(
                zone.passiveVolume,
                totalVolume
            );
            const absorptionScore =
                passiveRatio > this.enhancementConfig.passiveAbsorptionThreshold
                    ? passiveRatio
                    : FinancialMath.multiplyQuantities(
                          passiveRatio,
                          0 // confidence boost removed
                      );

            totalAbsorptionScore = FinancialMath.safeAdd(
                totalAbsorptionScore,
                absorptionScore
            );
        }

        return FinancialMath.divideQuantities(
            totalAbsorptionScore,
            relevantZones.length
        );
    }

    /**
     * Get enhancement statistics for monitoring and debugging
     *
     * STANDALONE VERSION: Statistics and monitoring interface
     */
    public getEnhancementStats(): AbsorptionEnhancementStats {
        return { ...this.enhancementStats };
    }

    /**
     * Log signal for validation tracking
     */
    private logSignalForValidation(
        signal: SignalCandidate,
        event: EnrichedTradeEvent,
        relevantZones: ZoneSnapshot[],
        thresholdChecks: AbsorptionThresholdChecks
    ): void {
        try {
            // Calculate market context for validation logging
            const marketContext = this.calculateMarketContext(
                event,
                relevantZones
            );

            // Add absorption-specific metrics
            const extendedContext = {
                ...marketContext,
                absorptionRatio: undefined as number | undefined,
            };

            if (
                signal.data &&
                typeof signal.data === "object" &&
                "absorptionScore" in signal.data
            ) {
                extendedContext.absorptionRatio = signal.data.absorptionScore;
            }

            this.validationLogger.logSignal(
                signal,
                event,
                thresholdChecks,
                marketContext
            );
        } catch (error) {
            this.logger.error(
                "AbsorptionDetectorEnhanced: Failed to log signal for validation",
                {
                    signalId: signal.id,
                    error:
                        error instanceof Error ? error.message : String(error),
                }
            );
        }
    }

    /**
     * Log signal rejection for threshold optimization
     */
    private logSignalRejection(
        event: EnrichedTradeEvent,
        rejectionReason: string,
        thresholdDetails: {
            type: string;
            threshold: number;
            actual: number;
        },
        thresholdChecks: AbsorptionThresholdChecks
    ): void {
        try {
            // Determine signal side based on trade direction
            const isBuyTrade = !event.buyerIsMaker;
            const signalSide = isBuyTrade ? "buy" : "sell";

            this.validationLogger.logRejection(
                "absorption",
                rejectionReason,
                event,
                thresholdDetails,
                thresholdChecks,
                signalSide
            );
        } catch (error) {
            this.logger.error(
                "AbsorptionDetectorEnhanced: Failed to log signal rejection",
                {
                    rejectionReason,
                    error:
                        error instanceof Error ? error.message : String(error),
                }
            );
        }
    }

    /**
     * Log successful signal parameters for 90-minute optimization
     */
    private logSuccessfulSignalParameters(
        signal: SignalCandidate,
        event: EnrichedTradeEvent,
        thresholdChecks: AbsorptionThresholdChecks
    ): void {
        try {
            // Collect ACTUAL VALUES that each parameter was checked against when signal passed

            // Market context at time of successful signal
            const marketContext = {
                marketVolume:
                    event.zoneData?.zones.reduce(
                        (sum, zone) =>
                            sum + zone.aggressiveVolume + zone.passiveVolume,
                        0
                    ) || 0,
                marketSpread:
                    event.bestAsk && event.bestBid
                        ? event.bestAsk - event.bestBid
                        : 0,
                marketVolatility: this.calculateMarketVolatility(event),
            };

            // Calculate the same values used in rejection logging

            this.validationLogger.logSuccessfulSignal(
                "absorption",
                event,
                thresholdChecks,
                marketContext,
                signal.side // Signal always has buy/sell
            );
        } catch (error) {
            this.logger.error(
                "AbsorptionDetectorEnhanced: Failed to log successful signal parameters",
                {
                    signalId: signal.id,
                    error:
                        error instanceof Error ? error.message : String(error),
                }
            );
        }
    }

    /**
     * Calculate market volatility estimate
     */
    private calculateMarketVolatility(event: EnrichedTradeEvent): number {
        // Simple volatility estimate based on spread and recent price action
        if (!event.bestAsk || !event.bestBid) return 0;

        const spread = event.bestAsk - event.bestBid;
        const midPrice = (event.bestAsk + event.bestBid) / 2;

        // Return spread as percentage of mid price
        return FinancialMath.divideQuantities(spread, midPrice);
    }

    /**
     * Calculate market context for validation logging
     */
    private calculateMarketContext(
        event: EnrichedTradeEvent,
        relevantZones: ZoneSnapshot[]
    ): {
        totalAggressiveVolume: number;
        totalPassiveVolume: number;
        aggressiveBuyVolume: number;
        aggressiveSellVolume: number;
        passiveBidVolume: number;
        passiveAskVolume: number;
        institutionalVolumeRatio: number;
        priceEfficiency: number | null;
    } {
        let totalAggressive = 0;
        let totalPassive = 0;
        let aggressiveBuy = 0;
        let aggressiveSell = 0;
        let passiveBid = 0;
        let passiveAsk = 0;

        // Aggregate volume data from relevant zones
        for (const zone of relevantZones) {
            totalAggressive = FinancialMath.safeAdd(
                totalAggressive,
                zone.aggressiveVolume
            );
            totalPassive = FinancialMath.safeAdd(
                totalPassive,
                zone.passiveVolume
            );
            aggressiveBuy = FinancialMath.safeAdd(
                aggressiveBuy,
                zone.aggressiveBuyVolume || 0
            );
            aggressiveSell = FinancialMath.safeAdd(
                aggressiveSell,
                zone.aggressiveSellVolume || 0
            );
            passiveBid = FinancialMath.safeAdd(
                passiveBid,
                zone.passiveBidVolume || 0
            );
            passiveAsk = FinancialMath.safeAdd(
                passiveAsk,
                zone.passiveAskVolume || 0
            );
        }

        const totalVolume = FinancialMath.safeAdd(
            totalAggressive,
            totalPassive
        );
        const institutionalVolumeRatio =
            totalVolume > 0
                ? FinancialMath.divideQuantities(totalPassive, totalVolume)
                : 0;

        // Calculate price efficiency based on volume-weighted price deviation
        const priceEfficiency = this.calculatePriceEfficiency(
            event,
            relevantZones
        );

        return {
            totalAggressiveVolume: totalAggressive,
            totalPassiveVolume: totalPassive,
            aggressiveBuyVolume: aggressiveBuy,
            aggressiveSellVolume: aggressiveSell,
            passiveBidVolume: passiveBid,
            passiveAskVolume: passiveAsk,
            institutionalVolumeRatio,
            priceEfficiency,
        };
    }

    /**
     * Enhanced cleanup - no legacy dependencies to clean up
     *
     * STANDALONE VERSION: Simple cleanup without legacy detector cleanup
     */
    public cleanup(): void {
        // Clean up validation logger
        this.validationLogger.cleanup();

        this.logger.info(
            "AbsorptionDetectorEnhanced: Standalone cleanup completed",
            {
                detectorId: this.getId(),
                enhancementStats: this.enhancementStats,
            }
        );
    }
}
